## 配列
<br>

- 変数は1つの中身を入れ替える箱だが、配列は複数の値を保持できる箱  
```rb
names = ["tanaka", "nakamura", "satou"]
puts names
```
<br>

```
#実行結果
tanaka
nakamura                                         
satou   
```
<br>
<br>

- 配列の中に配列を含めることもできる  
```rb
names = [["tanaka", "nakamura"], ["satou", "suzuki"]]
```
<br>
<br>

- インデックス番号で取り出せる  
```rb
names = ["tanaka", "nakamura", "satou"]
puts names[1]
#=> nakamura
```
<br>
<br>

- 色々な値の配列 
```rb
num = 100
mix = ["a" + "z", 1, "b", 2, num * 2]
["az", 1, "b", 2, 200]
```
<br>
<br>

- 配列に要素を追加する(<<)  
```rb
names = ["tanaka", "nakamura", "satou"]
names << "suzuki" #配列の末尾に追加される
p names
#=> ["tanaka", "nakamura", "satou", "suzuki"]
```
<br>
<br>

- 配列の先頭に要素を追加する(unshift)  
```rb
names = ["tanaka", "nakamura", "satou"]
names.unshift("kobayasi", "isikawa")  #複数の要素を追加できる #配列の先頭に追加される 
p names
#=> ["kobayasi", "isikawa", "tanaka", "nakamura", "satou"]
```
<br>
<br>

- 配列の末尾に複数の要素を追加する(push)
```rb
#<<は要素一つだけだが、pushは複数の要素を追加できる
names = ["tanaka", "nakamura", "satou"]
names.push("suzuki", "watanabe")  #複数の要素を追加できる #配列の末尾に追加される 
p names
#=> ["tanaka", "nakamura", "satou", "suzuki", "watanabe"]
```
<br>
<br>

- 配列の先頭の要素を削除する(shift)  
```rb
names = ["kobayasi", "isikawa", "tanaka", "nakamura", "satou"]
names.shift
p names
#=> ["isikawa", "tanaka", "nakamura", "satou"]
```
<br>
<br>

- 配列の末尾の要素を削除する(pop)  
```rb
names = ["tanaka", "nakamura", "satou", "suzuki", "watanabe"]
names.pop(2)
names
#=> ["tanaka", "nakamura", "satou"]
```
<br>
<br>

- sizeメソッドで配列の長さ(要素の個数)を取得する  
```rb
a = [1, 2, 3]
p a.size
#=> 3
```
<br>
<br>

- 添字を指定して値を代入する  
```rb
配列[添字] = 新しい値
a = [1, 2, 3]
a[1] = 20
p a
#=> [1, 20, 3]

#元の大きさよりも大きい添字を指定すると間の値がnilで埋められる
a = [1, 2, 3]
a[5] = 6
p a
#=> [1, 2, 3, nil, nil, 6]
```
<br>
<br>

- 配列内の特定の位置にある要素を削除する  
```rb
配列.delete_at(添字)
#=> 削除した値が戻り値になる
#=> 存在しない添字を指定するとnilが返る
a = [1, 2, 3, 4, 5]
a.delete_at(2)
#=> 3
p a
#=> [1, 2, 4, 5]    
```
<br>
<br>

- 配列の多重代入  
```rb
#変数と同じように配列も多重代入できる
#変数
a, b = 1, 2
a  #=> 1
b  #=> 2
#配列
a, b = [1, 2]
a  #=> 1
b  #=> 2

#配列で受け取るよりも多重代入で最初から別々の変数に入れた方がわかりやすいコードが書ける
#divmodメソッドは割り算の商と余りを配列で返す
14.divmod(3) #=> [4, 2]
#戻り値を配列のまま受け取る
quo_rem = 14.divmod(3)
#=> [4, 2]
#多重代入で別々の変数として受け取る
#quotient(日本語訳：商) remainder(日本語訳：残り)と別々の変数で扱った方がわかりやすいコードが書ける
quotient, remainder = 14.divmod(3)
p "商 =#{quotient}, 余り =#{remainder}"
#=> "商 =4, 余り =2" 
```
<br>
<br>

- さまざまな要素の取得方法  
```rb
#添字２つで添え字の位置と長さを指定できる
#配列[位置, 取得する長さ]
a = [1, 2, 3, 4, 5]
a[1, 3]  #=> [2, 3, 4]  #添え字1から取得し始めて3つ取得する
```
<br>

- Values_atメソッドで取得したい要素の添え字を複数指定する  
```rb
#配列.values_at(添え字1, 添え字2, 添え字3•••••)
a = [1, 2, 3, 4, 5]
a.values_at(0, 2, 4)  #=> [1, 3, 5]
```
<br>

- Rubyでは添え字に負の値が使用できる  
```rb
# -1は最後の要素  -2は最後から2番目の要素
a = [1, 2, 3, 4, 5]
a[-1]  #=> 5  #いちばん最後の要素を取得する
a[-2, 3]  #=>  [4, 5]  #最後から2番目の要素から3つ要素を取得する(5より先はないので2つだけ取得)
a.values_at(-1, -2, -5)  #=> [5, 4, 1]
```
<br>

- last, firstメソッド  
```rb
#lastメソッドは配列の最後の要素を取得する
a = [1, 2, 3, 4, 5]
a.last  #=> 5
a.last(3)  #=> [3, 4, 5]  #配列の最後から数えて3つの要素を取得する

#firstメソッドはlastメソッドの逆
a.first  #=> 1
a.first(3)  #=> [1, 2, 3]  #配列の最初から数えて3つの要素を取得する
```